indice

    Introducción general

    •Propósito del proyecto 
    •Descripción funcional 
    •Público objetivo •Tecnologías principales

    Estructura del proyecto

    •Descripción de carpetas y archivos clave •Archivos protegidos (no modificar) •Carpetas pensadas para extensión

    Instalación y configuración

    •Requisitos del sistema •Pasos para clonar e instalar el proyecto •Configuración inicial (APP y SERVER) •Cómo iniciar el proyecto localmente

    Flujo de ejecución

    •Carga dinámica de vistas •Estructura de rutas con .htaccess •Integración de layouts y componentes

    Convenciones de desarrollo

    •Nombres de archivos y funciones •Estructura de controladores y modelos •Uso de helpers y assets •Reglas para agregar nuevos componentes o vistas

    Frontend

    •Uso de Bootstrap (local y CDN) •Estructura de layouts (header, footer, etc.) •Organización de componentes HTML reutilizables •Integración de scripts JS y estilos CSS

    Backend

    •Funcionamiento de modelos (mainModel, herencia) •Acceso a datos y procesamiento de vistas •Uso de constantes globales (APP, SERVER) •Seguridad básica (encriptación, sanitización, etc.)

    Reutilización y helpers

    •Uso de fragmentos en helpers/js y helpers/php •Ejemplos de funciones reutilizables

    Testing y depuración

    •Métodos para probar vistas y funciones •Activación/desactivación de errores •Herramientas recomendadas para debugging

    Seguridad y buenas prácticas

    •Archivos que no deben modificarse •Manejo de credenciales y datos sensibles •Prevención de vulnerabilidades comunes

    Colaboración y control de versiones

    •Uso de Git (ramas, commits, .history) •Documentación de cambios •Reglas para contribuir (pull requests, revisiones) •Comandos recomendados para trabajo en equipo

    Documentación adicional

    •Contenido de la carpeta docs/ •Cómo agregar nuevos documentos •Mantenimiento del archivo README.md

    Extensión y mantenimiento

    •Agregar nuevas vistas, modelos o controladores •Actualización de dependencias con Composer •Escalabilidad del proyecto (módulos, plugins, etc.)

    Conclusión

    •Finalidad del manual •Recomendaciones generales •Responsabilidad compartida en el desarrollo

Propósito del Proyecto

    Este proyecto está diseñado como una aplicación web modular basada en el patrón MVC (Modelo-Vista-Controlador), orientada a facilitar el desarrollo escalable, seguro y mantenible de interfaces dinámicas en PHP. Su estructura permite:

        •Separación clara de responsabilidades entre lógica de negocio, presentación y control de flujo.

        •Carga dinámica de vistas mediante URLs amigables gestionadas por .htaccess, lo que mejora la navegación y la extensibilidad.

        •Gestión centralizada de constantes y configuración a través de los módulos APP y SERVER, permitiendo reutilización y seguridad.

        •Integración de componentes reutilizables (layouts, helpers, assets) para acelerar el desarrollo frontend sin duplicar código.

        •Seguridad incorporada mediante encriptación de datos sensibles, hashing de contraseñas y validación de sesiones.

        •Escalabilidad progresiva, permitiendo agregar nuevas vistas, modelos y controladores sin alterar la estructura base.

    El sistema está pensado para servir como plantilla base de proyectos PHP, adaptable a múltiples contextos: paneles administrativos, sitios informativos, sistemas internos o prototipos funcionales.

Descripción funcional

    Este proyecto es una aplicación web estructurada bajo el patrón MVC (Modelo-Vista-Controlador), diseñada para gestionar dinámicamente vistas PHP mediante rutas amigables. Su arquitectura modular permite una separación clara entre lógica de negocio, presentación y control de flujo, facilitando el mantenimiento, la escalabilidad y la reutilización de componentes tanto en frontend como backend.

Público objetivo

    Desarrolladores web que trabajen en entornos PHP y requieran una base estructurada para construir aplicaciones dinámicas, paneles administrativos, sistemas internos o prototipos funcionales. El proyecto está orientado a equipos técnicos que valoran la organización, la seguridad y la extensibilidad del código.

Tecnologías principales

    •PHP (con orientación a objetos y modularidad)

    •Composer (gestión de dependencias)

    •Bootstrap 5 (estilización y componentes frontend)

    •AJAX (peticiones de datos asíncronas)

    •JavaScript (interactividad y automatización)

    •Apache + .htaccess (reescritura de URLs y configuración del servidor)

    •HTML/CSS (estructura y presentación de vistas)

    •PDO (acceso seguro a bases de datos)

    •OpenSSL (encriptación de datos sensibles)

    •GIT/Github (control de versiones)

Estructura del proyecto

    La siguiente estructura organiza el proyecto bajo el patrón MVC, separando claramente la lógica de negocio, la presentación y el control de flujo. Cada módulo cumple una función específica y está diseñado para facilitar la escalabilidad, la reutilización y el mantenimiento.

        ->leer estructura_proyecto.txt

Archivos que no deben modificarse directamente

    •.htaccess

    •index.php

    •composer.json / composer.lock

    •config/SERVER/

    •model/mainModel/

Carpetas pensadas para extensión o personalización

    •view/html/ → Agregar nuevas vistas

    •assets/components/ → Crear nuevos fragmentos HTML reutilizables

    •helpers/js/ y helpers/php/ → Añadir funciones compartidas

    •docs/ → Documentar nuevas funcionalidades o decisiones técnicas

    •model/ → Crear nuevos modelos que extiendan mainModel

    •controller/ → Agregar nuevos controladores si se amplía la lógica

Instalación y configuración

    Esta sección describe los requisitos técnicos, los pasos para instalar el proyecto en un entorno local, y la configuración inicial necesaria para su correcto funcionamiento.

        Requisitos del sistema

            •PHP 8.0 o superior Recomendado para compatibilidad con tipado estricto, excepciones modernas y funciones criptográficas.

            •Servidor web Apache Incluido en XAMPP, necesario para interpretar .htaccess y servir archivos PHP.

            •Composer Gestor de dependencias para instalar Bootstrap y otras librerías PHP.

Pasos para clonar e instalar el proyecto

    •Clonar el repositorio en la carpeta htdocs de XAMPP utilizando Git.

    •Acceder al directorio del proyecto desde la terminal o consola.

    •Ejecutar el comando composer install para instalar las dependencias definidas en composer.json...

    •Verificar que la carpeta vendor esté presente y contenga Bootstrap y otras librerías necesarias.

Configuración inicial

    •El proyecto no utiliza variables de entorno .env, pero centraliza su configuración en dos módulos clave:

    •config/SERVER Contiene constantes sensibles como credenciales de base de datos, claves de encriptación, algoritmo de cifrado y cadena de conexión. Este archivo no debe modificarse sin autorización.

    •config/APP Contiene constantes generales como el nombre del sistema, la ruta base y configuraciones reutilizables en frontend y backend.

Cómo iniciar el proyecto localmente

    •Iniciar Apache desde el panel de control de XAMPP.

    •Acceder al proyecto desde el navegador mediante la URL http://localhost/proyecto/

    •El archivo index.php actúa como punto de entrada, cargando dinámicamente la vista correspondiente según el parámetro page en la URL.

Flujo de ejecución

    Esta sección describe cómo se carga una vista dentro del sistema, cómo se estructuran las rutas mediante .htaccess, y cómo se integran los layouts y componentes en la plantilla principal.

    Carga de una vista

        •El archivo index.php actúa como punto de entrada de la aplicación. Desde allí se instancia el controlador principal.

        •El controlador vista_controller.php obtiene el parámetro page desde la URL y lo utiliza para determinar qué vista debe cargarse.

        •El modelo vista_model.php valida si la vista solicitada existe en el sistema. Si no existe, retorna una vista de error (404).

        •Una vez determinada la vista, se carga la plantilla principal ubicada en view/plantilla, que incluye los elementos repetitivos del frontend.

        •La plantilla integra el contenido dinámico de la vista junto con los layouts definidos en assets/layouts (header, footer, scripts, etc.).

    Estructura de rutas

        •Las rutas son gestionadas por el archivo .htaccess, que reescribe cualquier URL en la forma index.php?page=nombre.

        •Esto permite acceder a vistas mediante URLs limpias como http://localhost/proyecto/inicio, sin exponer la estructura interna del sistema.

        •El parámetro page se interpreta como el nombre de la vista solicitada, y se utiliza para cargar dinámicamente el archivo correspondiente.

    Integración de layouts y componentes

        •Los layouts se encuentran en assets/layouts y contienen elementos comunes como header.php, footer.php, links.php y scripts.php.

        •Estos archivos son incluidos automáticamente por la plantilla principal, lo que garantiza consistencia visual y funcional en todas las vistas.

        •Los componentes reutilizables (ubicados en assets/components) pueden ser integrados dentro de cualquier vista o layout para modularizar la interfaz.

        •Esta estructura permite mantener el código organizado, evitar duplicación y facilitar la personalización del frontend.

Convenciones de desarrollo

    Esta sección establece las reglas y patrones que deben seguirse para mantener la coherencia, legibilidad y escalabilidad del código en todo el proyecto.

    Nombres de archivos y funciones

        •Los archivos PHP deben nombrarse en minúsculas y con guiones bajos para separar palabras (ejemplo: vista_controller.php).

        •Las funciones deben utilizar nombres descriptivos en estilo camelCase, reflejando claramente su propósito (ejemplo: cargarVista, desencriptarDato).

        •Los modelos y controladores deben seguir el patrón Nombre_tipo.php, donde tipo puede ser model o controller.

        •Las vistas deben nombrarse como nombre-view.php, donde nombre representa la sección o página correspondiente.

    Estructura de controladores y modelos

        •Cada controlador debe extender de un modelo si requiere acceso a métodos de negocio o utilitarios.

        •El controlador principal (vista_controller.php) se encarga de interpretar la URL y cargar la vista correspondiente.

        •El modelo principal (mainModel) contiene métodos comunes como conexión a base de datos, encriptación, validación y hashing.

        •Los modelos específicos deben extender de mainModel para heredar funcionalidad base y mantener consistencia.

    Uso de helpers y assets

        •Los helpers se dividen en js y php, y deben contener funciones reutilizables que no dependan de una vista específica.

        •Los assets se organizan por tipo: bootstrap, components, icons, images, layouts. Cada carpeta debe contener únicamente su tipo de recurso.

        •Los layouts deben incluirse mediante la plantilla principal y no directamente en las vistas.

        •Los componentes HTML deben diseñarse para ser independientes y reutilizables en múltiples vistas o layouts.

    Reglas para agregar nuevos componentes o vistas

        •Toda nueva vista debe agregarse en view/html y su nombre debe incluir el sufijo -view.php.

        •El nombre de la vista debe añadirse al arreglo paginas_existentes en vista_model.php para que sea reconocida por el sistema.

        •Los componentes nuevos deben ubicarse en assets/components y seguir una estructura modular.

        •Si se requiere lógica adicional para una vista, puede crearse un nuevo controlador que extienda de vista_controller o mainModel según el caso.

        •Los estilos y scripts específicos de una vista deben colocarse en view/css y view/js respectivamente, y enlazarse desde scripts.php o links.php.

Frontend

    Esta sección describe cómo se organiza y se implementa el frontend del proyecto, incluyendo el uso de Bootstrap, la estructura de layouts, la reutilización de componentes HTML y la integración de scripts y estilos.

    Cómo se usa Bootstrap (local o CDN)

        •Bootstrap puede utilizarse de dos formas: mediante archivos locales instalados con Composer o a través de un CDN.

        •Para uso local, los archivos bootstrap.min.css y bootstrap.bundle.min.js deben copiarse desde vendor/twbs/bootstrap/dist hacia la carpeta public y enlazarse en el HTML.

        •Para uso por CDN, se incluyen directamente en el archivo links.php y scripts.php mediante etiquetas <link> y <script> con las URLs oficiales.

        •Ambas opciones permiten utilizar las clases, componentes y utilidades de Bootstrap en todas las vistas del proyecto.

    Cómo se estructuran los layouts (header.php, footer.php, etc.)

        •Los layouts se encuentran en assets/layouts y contienen elementos comunes que se repiten en todas las vistas.

        •header.php incluye la cabecera visual del sitio, como logotipo, navegación o título.

        •footer.php contiene el pie de página con información adicional, enlaces o créditos.

        •links.php gestiona la inclusión de hojas de estilo y metadatos en el <head> del documento.

        •scripts.php gestiona la inclusión de archivos JavaScript necesarios para la funcionalidad del frontend.

        •Estos archivos son incluidos automáticamente por la plantilla principal, lo que garantiza consistencia en todas las páginas.

    Cómo se organizan los componentes HTML reutilizables

        •Los componentes HTML se ubican en assets/components y están diseñados para ser reutilizados en múltiples vistas o layouts.

        •Cada componente debe ser independiente, modular y contener únicamente la estructura necesaria para su función (ejemplo: tarjetas, botones, formularios).

        •Los componentes pueden incluirse mediante PHP usando include o require en cualquier parte del layout o vista.

        •Esta organización permite mantener el código limpio, evitar duplicación y facilitar la personalización de la interfaz.

    Cómo se integran los scripts JS y estilos CSS

        •Los scripts JavaScript específicos de cada vista se colocan en view/js y deben enlazarse desde scripts.php si se requiere su ejecución global.

        •Los estilos CSS personalizados se colocan en view/css y se enlazan desde links.php para que estén disponibles en todas las vistas.

        •Los scripts reutilizables se pueden ubicar en helpers/js y los estilos compartidos pueden integrarse en assets/bootstrap o en una hoja de estilos común.

    Esta estructura permite separar claramente los recursos globales de los específicos, facilitando el mantenimiento y la escalabilidad del frontend.
    
Backend

    Esta sección describe cómo se organiza y opera la lógica del backend, incluyendo el funcionamiento de los modelos, el acceso a datos, el uso de constantes globales y las medidas básicas de seguridad implementadas en el sistema.

    Cómo funcionan los modelos (mainModel, herencia, etc.)

        •El modelo principal mainModel contiene métodos reutilizables para conexión a base de datos, encriptación, hashing de contraseñas, validación y desencriptación de sesiones.

        •Los modelos específicos deben extender de mainModel para heredar su funcionalidad base y evitar duplicación de código.

        •El modelo vista_model se encarga de validar qué vista debe cargarse según el parámetro recibido desde el controlador.

        •La herencia permite que cualquier modelo acceda a métodos comunes sin necesidad de redefinirlos, manteniendo el sistema modular y escalable.

    Cómo se accede a datos o se procesan vistas

        •El método conectar_base_datos de mainModel establece una conexión segura con la base de datos utilizando PDO.

        •Las consultas se realizan mediante el método consulta, que recibe una sentencia SQL como string y devuelve el resultado preparado.

        •Las vistas se procesan dinámicamente a través del controlador vista_controller, que interpreta el parámetro page y solicita al modelo vista_model la vista correspondiente.

        •La vista obtenida se integra en la plantilla principal junto con los layouts, generando la salida final para el navegador.

    Uso de constantes globales (APP, SERVER)

        •El módulo config/APP contiene constantes generales como el nombre del sistema, rutas base y configuraciones reutilizables en frontend y backend.

        •El módulo config/SERVER contiene constantes sensibles como credenciales de base de datos, claves de encriptación, algoritmo de cifrado y parámetros de seguridad.

        •Estas constantes se incluyen automáticamente en los modelos y controladores mediante include_once, permitiendo su uso en todo el sistema sin redefinirlas.

        •La separación entre APP y SERVER permite mantener la seguridad y la claridad en la configuración del proyecto.

    Seguridad básica (encriptación, sanitización, etc.)

        •Los datos sensibles se encriptan mediante el método encriptar_dato de mainModel, utilizando OpenSSL con claves definidas en SERVER.

        •Las contraseñas se hashean mediante password_hash con un coste ajustado para evitar ataques por fuerza bruta.

        •La verificación de contraseñas se realiza con password_verify, comparando el valor ingresado con el hash almacenado.

        •Las sesiones pueden desencriptarse mediante desencriptar_sesion, lo que permite acceder a datos del usuario de forma segura.

        •Las consultas SQL deben construirse cuidadosamente para evitar inyecciones, utilizando prepare y execute en lugar de concatenación directa.

        •El sistema valida tipos de datos y lanza excepciones si los parámetros no cumplen con el formato esperado, lo que refuerza la integridad del backend.

Reutilización y helpers

    Esta sección explica cómo aprovechar los fragmentos de código ubicados en helpers/js y helpers/php para evitar duplicación, mejorar la organización y facilitar el mantenimiento del sistema.

    Cómo y cuándo usar los fragmentos de código en helpers/js y helpers/php

        •Los archivos en helpers/js contienen funciones JavaScript reutilizables que pueden aplicarse en múltiples vistas o componentes sin depender de una estructura específica.

        •Los archivos en helpers/php contienen funciones auxiliares que encapsulan lógica común del backend, como validaciones, formateo de datos o generación de estructuras HTML dinámicas.

        •Se recomienda utilizar estos helpers cuando una función se repite en más de una vista, controlador o componente, o cuando se desea mantener el código limpio y modular.

        •Los helpers deben mantenerse independientes, sin acoplamiento directo a vistas o modelos específicos, para garantizar su reutilización en distintos contextos.

        •Para incluir un helper en PHP, se utiliza include_once o require_once desde el archivo que lo necesite. En JavaScript, se puede importar o enlazar el archivo desde scripts.php si se requiere en el frontend.

    Ejemplos de funciones reutilizables

        •helpers/php/validarEntrada.php Función que verifica si una cadena cumple con criterios de seguridad (longitud, caracteres permitidos, etc.).

        •helpers/php/formatearFecha.php Función que convierte una fecha en formato base de datos a formato legible para el usuario.

        •helpers/php/generarToken.php Función que crea un token único para formularios o sesiones, útil para prevenir ataques CSRF.

        •helpers/js/mostrarAlerta.js Función que despliega una alerta personalizada en pantalla con parámetros de tipo, mensaje y duración.

        •helpers/js/validarFormulario.js Función que recorre los campos de un formulario y verifica que cumplan con las reglas definidas antes de enviarlo.

        •helpers/js/activarComponente.js Función que inicializa un componente Bootstrap (como tooltip o modal) en vistas que lo requieran.

    Estas funciones pueden ampliarse o adaptarse según las necesidades del proyecto, manteniendo siempre la lógica separada del flujo principal.

Testing y depuración

    Esta sección describe los métodos recomendados para verificar el funcionamiento correcto de vistas y funciones, cómo gestionar la visualización de errores, y qué herramientas pueden facilitar el proceso de depuración durante el desarrollo.

    Métodos recomendados para probar vistas o funciones

        •Acceder directamente a cada vista mediante la URL http://localhost/proyecto/nombre, verificando que se cargue correctamente y que los componentes se integren como se espera.

        •Utilizar valores de prueba en formularios y entradas para validar la respuesta del sistema, especialmente en funciones que involucran encriptación, sesiones o base de datos.

        •Incluir mensajes temporales en el flujo de ejecución (echo, var_dump, print_r) para inspeccionar el contenido de variables y estructuras durante el desarrollo.

        •Verificar que los controladores y modelos respondan correctamente a parámetros esperados y que las excepciones se manejen adecuadamente.

    Cómo activar/desactivar logs o errores

        Para activar la visualización de errores en PHP, modificar el archivo php.ini o incluir directamente en index.php:

        error_reporting(E_ALL); ini_set("display_errors", 1);

        Para desactivar los errores en producción, se recomienda:

        error_reporting(0); ini_set("display_errors", 0);

    Los errores también pueden registrarse en archivos de log si se configura log_errors en php.ini y se define error_log. Es importante no dejar la visualización de errores activa en entornos públicos por razones de seguridad.

    Herramientas sugeridas para debugging

        •XAMPP Panel Permite monitorear el estado de Apache y MySQL, reiniciar servicios y acceder a logs del servidor.

        •Extensión .history en VSCode Registra cambios realizados en archivos, útil para rastrear modificaciones durante el desarrollo.

        •Consola del navegador Herramienta esencial para depurar errores de JavaScript, verificar carga de recursos y analizar el DOM.

        •Inspección de red (Network tab) Permite verificar que los archivos CSS, JS y peticiones fetch se carguen correctamente.

        •var_dump y print_r Funciones nativas de PHP para inspeccionar el contenido de variables, arrays y objetos.

        •Herramientas externas como Postman o Insomnia Pueden utilizarse para probar endpoints si se agregan funcionalidades tipo API en el futuro.

    Estas herramientas permiten identificar errores rápidamente, validar el comportamiento esperado y mejorar la calidad del código durante el desarrollo.

Seguridad y buenas prácticas

    Esta sección establece las recomendaciones clave para proteger la integridad del sistema, evitar vulnerabilidades comunes y mantener una base de código segura y confiable durante el desarrollo.

    Qué archivos no deben tocarse (.htaccess, composer.lock, etc.)

        •.htaccess Archivo de configuración del servidor Apache que gestiona la reescritura de URLs. No debe modificarse sin conocimiento técnico, ya que afecta el enrutamiento de toda la aplicación.

        •composer.lock Archivo que registra las versiones exactas de las dependencias instaladas. No debe editarse manualmente para evitar inconsistencias en el entorno de ejecución.

        •config/SERVER Contiene credenciales y claves de seguridad. No debe modificarse sin autorización ni compartirse en entornos públicos.

        •vendor Carpeta generada por Composer que contiene librerías externas. No debe alterarse directamente; cualquier cambio debe gestionarse mediante composer.json..

        •index.php Punto de entrada principal del sistema. No debe modificarse sin comprender el flujo completo de ejecución.

    Cómo manejar credenciales y datos sensibles

        •Las credenciales de base de datos, claves de encriptación y parámetros de seguridad se definen en config/SERVER como constantes.

        •Estos datos deben mantenerse fuera del control de versiones (Git) si el proyecto se publica, utilizando mecanismos como .gitignore para protegerlos.

        •Nunca deben exponerse en el frontend ni imprimirse en pantalla, incluso durante pruebas o debugging.

        •Se recomienda utilizar nombres descriptivos pero no reveladores para las constantes, y mantenerlas agrupadas por función (acceso, cifrado, cliente).

        •En entornos más avanzados, puede considerarse el uso de archivos .env o gestores de secretos externos para mayor seguridad.

    Recomendaciones para evitar vulnerabilidades comunes

        •Utilizar métodos preparados (prepare + execute) para todas las consultas SQL, evitando concatenación directa que pueda permitir inyección.

        •Hashear todas las contraseñas antes de almacenarlas, utilizando password_hash con un coste adecuado para evitar ataques por fuerza bruta.

        •Verificar siempre los tipos de datos recibidos en funciones y métodos, lanzando excepciones si no cumplen con el formato esperado.

        •Encriptar los datos sensibles antes de almacenarlos o transmitirlos, utilizando OpenSSL con claves definidas en SERVER.

        •Validar y sanitizar todas las entradas del usuario, especialmente en formularios, URLs y parámetros GET/POST.

        •Evitar mostrar errores detallados en producción, desactivando display_errors y utilizando logs privados para registrar fallos.

        •Mantener actualizadas las dependencias mediante Composer, revisando periódicamente las versiones y vulnerabilidades conocidas.

        •Separar claramente la lógica del backend y la presentación del frontend, evitando que el usuario tenga acceso directo a archivos internos o rutas protegidas.

Colaboración y control de versiones

    Esta sección establece las prácticas recomendadas para trabajar en equipo utilizando Git, documentar cambios correctamente y contribuir al proyecto sin afectar el trabajo de otros desarrolladores.

    Uso de Git (ramas, commits, .history)

        •El proyecto utiliza Git como sistema de control de versiones para rastrear cambios, colaborar en paralelo y mantener un historial limpio.

        •Cada desarrollador debe trabajar en una rama propia, basada en la versión más reciente de la rama principal (master), para evitar conflictos y sobrescritura de trabajo ajeno.

        •Los commits deben ser descriptivos, breves y reflejar claramente el propósito del cambio realizado.

        •La extensión .history en VSCode registra automáticamente los cambios en archivos, lo que permite revisar ediciones recientes y facilitar la depuración.

    Cómo documentar cambios

        •Cada commit debe incluir un mensaje claro que indique qué se modificó, por qué y en qué parte del sistema.

        •Los cambios significativos deben documentarse adicionalmente en el archivo README.md o en la carpeta docs si afectan la estructura, el flujo o la configuración del proyecto.

        •Se recomienda usar comentarios en el código para explicar decisiones técnicas, especialmente en funciones complejas o estructuras no evidentes.

        •Los desarrolladores deben mantener un registro de sus tareas y avances para facilitar la revisión y el seguimiento del progreso.

    Reglas para contribuir (pull requests, revisiones)

        •Toda contribución debe realizarse desde una rama independiente, creada a partir de la versión actualizada de master.

        •Antes de iniciar trabajo en una nueva rama, el desarrollador debe sincronizar su entorno con la última versión de master para evitar conflictos.

        •Las pull requests deben ser claras, contener solo los cambios necesarios, y estar acompañadas de una breve descripción funcional.

        •Las revisiones deben enfocarse en la calidad del código, la coherencia con las convenciones del proyecto y la compatibilidad con el sistema existente.

        •No se debe fusionar una pull request sin revisión previa ni sin confirmar que no se sobrescriben cambios de otros colaboradores.

    Comandos recomendados para trabajar correctamente con ramas

        •Clonar el repositorio: git clone https://github.com/usuario/proyecto.git

        •Acceder al proyecto: cd proyecto

        •Actualizar la rama principal: git checkout master git pull origin master

        •Crear una nueva rama para trabajar: git checkout -b nombre-de-tu-rama

        •Agregar y confirmar cambios: git add . git commit -m "Descripción clara del cambio"

        •Subir la rama al repositorio remoto: git push origin nombre-de-tu-rama

        •Solicitar revisión mediante pull request desde GitHub, comparando tu rama con master.

        •Mantener tu rama sincronizada con master antes de hacer el pull request: git checkout master git pull origin master git checkout nombre-de-tu-rama git merge master

        •Resolver conflictos si aparecen, probar localmente, y luego subir los cambios corregidos: git push origin nombre-de-tu-rama

    Estas prácticas aseguran que el trabajo en equipo sea ordenado, seguro y compatible, evitando sobrescritura de código y facilitando la integración de nuevas funcionalidades.

Documentación adicional

    Esta sección describe el propósito de la carpeta docs, cómo se deben agregar nuevos documentos técnicos al proyecto, y las recomendaciones para mantener actualizado el archivo README.md..

    Qué hay en docs/

        •La carpeta docs contiene archivos de texto que documentan aspectos clave del proyecto, tareas pendientes y convenciones internas.

        •cosas_pendientes.txt Lista de tareas por completar, mejoras sugeridas o funcionalidades en desarrollo. Útil para organizar el trabajo colaborativo.

        •estructura_proyecto.txt Descripción jerárquica de la arquitectura del sistema, útil para onboarding de nuevos desarrolladores.

        •manual_desarrollador.txt Documento principal que explica el funcionamiento técnico del proyecto, buenas prácticas y guías de contribución.

        •Estos archivos pueden ser editados directamente desde el editor de código y están sujetos a control de versiones mediante Git.

    Cómo agregar nuevos documentos

        •Todo nuevo documento debe ubicarse dentro de la carpeta docs y utilizar nombres descriptivos en minúsculas, separados por guiones bajos.

        •El contenido debe ser claro, estructurado y relevante para el desarrollo, mantenimiento o extensión del proyecto.

        •Se recomienda incluir encabezados, listas y secciones bien definidas para facilitar la lectura y consulta.

        •Los documentos pueden abordar temas como decisiones técnicas, convenciones específicas, flujos alternativos, notas de implementación o referencias externas.

        •Una vez creado el documento, debe agregarse al repositorio mediante Git para que esté disponible para todos los colaboradores.

    Cómo mantener actualizado el README.md

        •El archivo README.md ubicado en la raíz del proyecto debe contener una descripción general del sistema, instrucciones de instalación y uso básico.

        •Cada vez que se agregue una funcionalidad importante, se modifique la estructura o se actualicen los requisitos, el README.md debe reflejar esos cambios.

        •Se recomienda mantener una sección de historial de versiones o changelog para registrar las actualizaciones más relevantes.

        •El README.md debe ser claro, conciso y útil para cualquier desarrollador que acceda al repositorio por primera vez.

    Actualizar este archivo es responsabilidad compartida del equipo, y debe considerarse parte del flujo de trabajo al realizar contribuciones significativas.

Extensión y mantenimiento

    Esta sección describe cómo ampliar la funcionalidad del sistema mediante nuevas vistas, modelos o controladores, cómo mantener actualizadas las dependencias del proyecto, y qué estrategias permiten escalar la arquitectura hacia módulos o integraciones más complejas.

    Cómo agregar nuevas vistas, modelos o controladores

        •Para agregar una nueva vista, crear un archivo en view/html con el nombre nombre-view.php, siguiendo la convención establecida.

        •Registrar el nombre de la vista en el arreglo paginas_existentes dentro de vista_model.php para que el sistema la reconozca y la cargue correctamente.

        •Si la vista requiere lógica adicional, puede crearse un nuevo controlador en controller/, extendiendo de vista_controller o directamente de mainModel si se necesita acceso a métodos del backend.

        •Los modelos nuevos deben ubicarse en model/, y deben extender de mainModel para heredar funcionalidades como conexión a base de datos, encriptación y validación.

        •Los controladores deben incluirse en index.php o en el flujo correspondiente si se desea que participen en la carga dinámica de vistas.

    Cómo actualizar dependencias con Composer

        •Para verificar las dependencias instaladas, revisar el archivo composer.json en la raíz del proyecto.

        •Para actualizar todas las dependencias a sus versiones más recientes compatibles: composer update

        •Para instalar una nueva dependencia específica: composer require nombre/paquete

        •Después de cualquier cambio en las dependencias, verificar que la carpeta vendor se haya actualizado correctamente y que no se hayan roto rutas o integraciones.

        •No modificar manualmente composer.lock; este archivo se actualiza automáticamente al ejecutar composer update o composer require.

    Cómo escalar el proyecto (módulos, plugins, etc.)

        •El sistema puede escalarse modularmente agregando nuevos controladores, modelos y vistas que sigan la estructura MVC definida.

        •Los módulos pueden organizarse como subcarpetas dentro de src/ si se desea agrupar funcionalidades por dominio (ejemplo: usuarios, productos, reportes).

        •Los plugins o librerías externas pueden integrarse mediante Composer, siempre que se mantenga la compatibilidad con la versión de PHP y la estructura del proyecto.

        •Para funcionalidades más complejas, se pueden definir rutas específicas en .htaccess y crear controladores dedicados para manejar flujos independientes.

        •La arquitectura permite incorporar APIs, sistemas de autenticación, paneles administrativos o integraciones externas sin romper la base del sistema.

    Es recomendable documentar cada módulo nuevo en docs/ y mantener una convención clara para su inclusión y mantenimiento.

Conclusión

Este manual de desarrollador proporciona una guía completa para comprender, utilizar y extender el sistema de forma segura, ordenada y colaborativa. Desde la estructura modular basada en MVC hasta las prácticas recomendadas de seguridad, control de versiones y documentación, cada sección está diseñada para facilitar el trabajo técnico y mantener la calidad del proyecto a lo largo del tiempo.

El objetivo es que cualquier desarrollador que se integre al equipo pueda comprender rápidamente el funcionamiento del sistema, contribuir de manera efectiva y mantener la coherencia del código sin comprometer la estabilidad ni la seguridad.

Se recomienda revisar este manual periódicamente, actualizarlo conforme evolucione el proyecto, y utilizarlo como referencia principal para decisiones técnicas, integración de nuevas funcionalidades y resolución de dudas durante el desarrollo.

La claridad, la modularidad y la colaboración son pilares fundamentales de este sistema. Mantenerlos activos es responsabilidad compartida de todos los desarrolladores que trabajen sobre esta base.